/* $Id$
 * $Revision$
 * $Date$
 * $Author$
 *
 * The Summa project.
 * Copyright (C) 2005-2007  The State and University Library
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */
package dk.statsbiblioteket.summa.facetbrowser.build.facet;

import java.util.LinkedHashSet;
import java.util.HashMap;
import java.util.Arrays;
import java.util.Properties;

import org.apache.log4j.Logger;
import dk.statsbiblioteket.summa.facetbrowser.util.ClusterCommon;
import dk.statsbiblioteket.summa.facetbrowser.util.pool.SortedPool;
import dk.statsbiblioteket.summa.facetbrowser.core.StructureDescription;
import dk.statsbiblioteket.util.qa.QAInfo;

/**
 * The State and University Library of Denmark
 * User: te
 * Date: Jun 6, 2006
 * Time: 10:11:23 AM
 * CVS:  $Id$
 * @deprecated in favor of {@link SortedPool}.
 */
@QAInfo(level = QAInfo.Level.NOT_NEEDED,
        state = QAInfo.State.UNDEFINED,
        author = "te")
public class FacetModelFactory<T> {
    private static final Logger log = Logger.getLogger(FacetModelFactory.class);

    private int maxFacets;
    private int maxTags;
    private int maxObjects;
    private LinkedHashSet<Element.SortOrder> facetSortOrders;
    private HashMap<String, Integer>         facetCustomOrder;
    private LinkedHashSet<Element.SortOrder> tagSortOrders;
    private HashMap<String, Integer>         tagCustomOrder;

    public FacetModelFactory() {
        init();
    }
    public FacetModel<T> getFacetModel() {
        FacetModel<T> model = new FacetModelImplOO<T>();
        model.setProperties(maxFacets, maxTags, maxObjects,
                            facetSortOrders, facetCustomOrder,
                            tagSortOrders, tagCustomOrder);
        return model;
    }

    /**
     * Set default values, according to properties.
     */
    public void init() {
        log.trace("Initializing...");
        Properties properties = ClusterCommon.getProperties();
        // TODO: Find out if we need the code below
        /*
        try {
            maxFacets = Integer.parseInt(properties.
                    getProperty(StructureDescription.MAX_FACETS, "15"));
        } catch (NumberFormatException e) {
            log.warn("Property for default_maxClusterFacets was not a number. "
                     + "Defaulting to 15 facets.", e);
        }
          */
        try {
            maxTags = Integer.parseInt(properties.
                    getProperty(StructureDescription.DEFAULT_MAX_CLUSTER_TAGS, "5"));
        } catch (NumberFormatException e) {
            log.warn("Property for default_maxClusterTags was not a number. "
                     + "Defaulting to 5 tags.", e);
        }

        try {
            maxObjects = Integer.parseInt(properties.
                    getProperty("default_maxClusterObjects", "5"));
        } catch (NumberFormatException e) {
            log.warn("Property for default_maxClusterObjects was not a number. "
                     + "Defaulting to 5 objects.", e);
        }

        facetSortOrders =
                expandSort(ClusterCommon.getProperty("ClusterFacetSort"));
        facetCustomOrder =
              expandCustom(ClusterCommon.getProperty("ClusterFacetSortCustom"));
        tagSortOrders =
                expandSort(ClusterCommon.getProperty("ClusterTagSort"));
        tagCustomOrder =
              expandCustom(ClusterCommon.getProperty("ClusterTagSortCustom"));
        log.trace("Finished initializing");
    }

    public void setProperties(int maxFacets, int maxTags, int maxObjects) {
        this.maxFacets = maxFacets;
        this.maxTags = maxTags;
        this.maxObjects = maxObjects;
    }
    /**
     * Set the properties for FacetModels generated by this factory.
     * @param maxFacets        the maximum number of Facets, -1 = unlimited
     * @param maxTags          the maximum number of Tags, -1 = unlimited
     * @param maxObjects       the maximum number of Objects, -1 = unlimited
     * @param facetSortOrders  the sort order for the facets
     * @param facetCustomOrder the strings for TagSortOrder.CUSTOM. If CUSTOM is
     *                         not specified as sortOrder, this argument can
     *                         be null
     * @param tagSortOrders    the sort order for the tags
     * @param tagCustomOrder   the strings for TagSortOrder.CUSTOM. If CUSTOM is
     *                         not specified as sortOrder, this argument can
     *                         be null
     */
    public void setProperties(int maxFacets, int maxTags, int maxObjects,
                              LinkedHashSet<Element.SortOrder> facetSortOrders,
                              HashMap<String, Integer> facetCustomOrder,
                              LinkedHashSet<Element.SortOrder> tagSortOrders,
                              HashMap<String, Integer> tagCustomOrder) {
        log.trace("setProperties called");
        this.maxFacets = maxFacets;
        this.maxTags = maxTags;
        this.maxObjects = maxObjects;
        this.facetSortOrders = facetSortOrders;
        this.facetCustomOrder = facetCustomOrder;
        this.tagSortOrders = tagSortOrders;
        this.tagCustomOrder = tagCustomOrder;
    }

    /**
     * Helper method for converting a SOrtOrder array to a LinkedHashSet.
     * @param sortOrders the TagSortOrder as an array
     * @return a hashmap of the sortOrders, in the same sequence. If the
     *         sortOrders is null, null is returned
     */
    protected static LinkedHashSet<Element.SortOrder>
            expandSort(Element.SortOrder[] sortOrders) {
        LinkedHashSet<Element.SortOrder> map =
                sortOrders == null ? null :
                new LinkedHashSet<Element.SortOrder>(sortOrders.length);
        if (sortOrders != null) {
            map.addAll(Arrays.asList(sortOrders));
        }
        return map;
    }
    public static LinkedHashSet<Element.SortOrder>
            expandSort(String orderProperty) {
        if (orderProperty == null || orderProperty.length() == 0) {
            return null;
        }
        String[] orders = orderProperty.split(", |,");
        LinkedHashSet<Element.SortOrder> result =
                            new LinkedHashSet<Element.SortOrder>(orders.length);
        for (String order: orders) {
            try {
                Element.SortOrder orderEnum = Element.SortOrder.valueOf(order);
                result.add(orderEnum);
            } catch (IllegalArgumentException ex) {
                log.error("Unknown TagSortOrder " + order);
            }
        }
        return result;
    }
    /**
     * Helper method for converting a custom order to a HashMap. The pairs
     * in the HashMap will be [(string1, 1), (string2, 2), ... (stringN, N)].
     * @param custom an array of strings for custom order search
     * @return a HashMap based on the custom array
     */
    protected static HashMap<String, Integer> expandCustom(String[] custom) {
        HashMap<String, Integer> customMap =
                custom == null ? null :
                new HashMap<String, Integer>(custom.length);
        int counter = 0;
        if (custom != null) {
            for (String c: custom) {
                customMap.put(c, counter++);
            }
        }
        return customMap;
    }
    public static HashMap<String, Integer> expandCustom(String custom) {
        return custom == null ? null : expandCustom(custom.split(", |,"));
    }
}
