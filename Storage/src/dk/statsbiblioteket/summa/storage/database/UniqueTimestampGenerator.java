package dk.statsbiblioteket.summa.storage.database;

/**
 * Utility class that generates unique timestamps. The resulting timestamps
 * can not be treated as dates directly since they are constructed from the
 * system time by appending a salt. To retrieve the system time from the
 * generated timestamps use {@link #systemTime(long)}.
 */
public class UniqueTimestampGenerator {

    public static final int TIME_BITS = 44;
    public static final int SALT_BITS = 64 - TIME_BITS;
    public static final long SALT_MAX = ~0 >>> TIME_BITS;    // ~0 is all ones

    private long salt;
    private long last;

    public UniqueTimestampGenerator() {
        salt = 0;
        last = 0;
    }

    /**
     * Return a salted timestamp that is guaranteed to be unique among all
     * timestamps generated from this UniqueTimestampGenerator instance.
     * <p/>
     * To get the system time from the returned timestamp use the
     * {@link #systemTime(long)} method
     * @return
     */
    public long next() {
        long sysTime = System.currentTimeMillis();

        updateSalt(sysTime);

        // If we reached the maximum salt value wait 1ms
        // (this will reset the salt)
        if (salt > SALT_MAX) {
            try {
                Thread.sleep(1);
            } catch (InterruptedException e) {
                // Ignore
            }
            return next();
        }

        return applySalt(sysTime);
    }

    /**
     * WARNING: Debug only - this method throws a RuntimeException if it is
     * impossible to create a unique timestamp.
     * @param systemTime
     * @return
     */
    long next(long systemTime) {
        updateSalt(systemTime);

        if (salt > SALT_MAX) {
            // We are screwed since this method can not just sleep() to wait for
            // a new system time...
            throw new RuntimeException("Forced to create non-unique "
                                       + "salted timestamp");
        }

        return applySalt(systemTime);
    }

    /**
     * Applies the salt to the given system time. The returned value is valid
     * timestamp. To re-create the system time use {@link #systemTime(long)}
     *
     * @param systemTime the system timestamp to apply the salt to
     * @return a valid timestamp in the context of this class - ie. not a system
     *         time, but a salted timestamp that is a globally unique identifier
     */
    private long applySalt(long systemTime) {
        systemTime = systemTime << SALT_BITS;
        systemTime = systemTime | salt;
        return systemTime;
    }

    /**
     * If the system time has changed reset the salt,
     * the stamp will still be unique because the time-part has changed
     * @param systemTime the system time that should be used to calculate the
     *                   next salt value for
     */
    private void updateSalt(long systemTime) {
        if (systemTime == last) {
            salt++;
        } else {
            salt = 0;
            last = systemTime;
        }
    }

    /**
     * Extract the system time from a timestamp generated with {@link #next()}.
     * @param timestamp the system time as returned by
     * {@link System#currentTimeMillis()} on the creation of {@code timeStamp}
     * @return
     */
    public long systemTime(long timestamp) {
        return timestamp >>> SALT_BITS;
    }

    /**
     * Extract the salt part of {@code timeStamp}. The salt is unique for each
     * millisecond. That is for two time stamps {@code t1, t2} where
     * {@code systemTime(t1) == systemTime(t2)} the salt is guaranteed to be
     * different
     * @param timestamp the timestamp as generated by {@link #next()} to extract
     *                  the salt value from
     * @return the salt applied to timestamp to make it unique
     */
    public long salt(long timestamp) {
        // Clear the first TIME_BITS and return
        // (only the salt should be untouched)
        timestamp = timestamp << TIME_BITS;
        return timestamp >>> TIME_BITS;
    }

}
