<?xml version="1.0" encoding="UTF-8" ?>

<config>

  <luceneMatchVersion>LUCENE_40</luceneMatchVersion>

  <!-- We might need this later if IndexLookUp is put in own jar/patch etc
         <lib dir="./lib" />  A whole directory
         <lib path="../some_patch.jar" /> Single jar. This file must exist or startup will fail 
  -->
  
  <!-- Specify where index is stored. Default is /data under SOLR_HOME.-->
  <dataDir>${solr.data.dir:}</dataDir>

  <!-- The DirectoryFactory to use for indexes. Can be changed to NIO, memory based etc.  -->
  <directoryFactory name="DirectoryFactory"  class="${solr.directoryFactory:solr.StandardDirectoryFactory}"/>

  <indexConfig>
    
       <maxFieldLength>50000</maxFieldLength>  <!-- maxFieldLength specifies max number of *tokens* indexed per field. Default: 10000 -->
       <writeLockTimeout>1000</writeLockTimeout> <!-- Maximum time to wait for a write lock (ms) for an IndexWriter. Default: 1000 -->
       
       <!-- Default false(recommended) in SOLR4.0. Setting it to true may improve performance at the cost of more files in the index directory.-->         
       <useCompoundFile>false</useCompoundFile>

       <ramBufferSizeMB>32</ramBufferSizeMB> 
       <maxBufferedDocs>1000</maxBufferedDocs>

       <unlockOnStartup>false</unlockOnStartup>
    
       <termIndexInterval>128</termIndexInterval> <!-- Default is 128 which is good for most. Can be used for performance tuning. --> 
       <reopenReaders>true</reopenReaders>
   
       <!-- <infoStream file="INFOSTREAM.txt">false</infoStream> -->  <!-- Enable if we want lucene debug information -->
  </indexConfig>


  <!-- The default high-performance update handler -->
  <updateHandler class="solr.DirectUpdateHandler2">

    <!-- OpenSearcher - if false, the commit causes recent index changes to be flushed to stable storage, but does not cause a new
         searcher to be opened to make those changes visible. -->
     <autoCommit> 
       <maxTime>15000</maxTime> 
       <openSearcher>false</openSearcher> 
     </autoCommit>
  
    <updateLog>
      <str name="dir">${solr.data.dir:}</str>
    </updateLog>
   

  </updateHandler>
  
  <query>
  
    <!--Maximum number of clauses in each BooleanQuery,  an exception is thrown if exceeded. -->        
    <maxBooleanClauses>1024</maxBooleanClauses> 


    <!--Advanced properties. Defaults -->
    <filterCache class="solr.FastLRUCache"
                 size="512"
                 initialSize="512"
                 autowarmCount="0"/>

    <queryResultCache class="solr.LRUCache"
                     size="512"
                     initialSize="512"
                     autowarmCount="0"/>
   
    <documentCache class="solr.LRUCache"
                   size="512"
                   initialSize="512"
                   autowarmCount="0"/>
    
    <enableLazyFieldLoading>true</enableLazyFieldLoading>


   <!-- 20 is default. Summa shows 20 records on page 1. Next page (records 21-40) is cached   -->
   <queryResultWindowSize>40</queryResultWindowSize>

   <!-- Changed from default 200 -->   
   <queryResultMaxDocsCached>1000</queryResultMaxDocsCached>

   <!-- Query Related Event Listeners        -->
    <listener event="newSearcher" class="solr.QuerySenderListener">
      <arr name="queries">
        <!--
           <lst><str name="q">solr</str><str name="sort">price asc</str></lst>
           <lst><str name="q">rocks</str><str name="sort">weight asc</str></lst>
          -->
      </arr>
    </listener>
    <listener event="firstSearcher" class="solr.QuerySenderListener">
      <arr name="queries">
        <lst>
          <str name="q">static firstSearcher warming in solrconfig.xml</str>
        </lst>
      </arr>
    </listener>

    <useColdSearcher>false</useColdSearcher>
    <maxWarmingSearchers>2</maxWarmingSearchers>

  </query>



  <requestDispatcher handleSelect="true" >


    <!-- For Security set this to false. We do not need remote streaming --> 
    <requestParsers enableRemoteStreaming="false" multipartUploadLimitInKB="2048000" />

    <httpCaching never304="true" />   
  </requestDispatcher>
    
    
<!--
Field boost not working exactly as intended. summa identity alias'es with boost (lperi=lperi^2.0 etc.) are not boosted
Also boost are not applied to fields when specifing several fields in query and the default dismax is not used.
But this is avery rare situation.
-->  
    
<requestHandler name="/edismax" default="true" class="solr.SearchHandler">
   <lst name="defaults">
     <str name="echoParams">explicit</str>
     <!-- Query settings -->
     <str name="defType">edismax</str>
     <str name="rows">10</str>
     <str name="qf">
       sort_title
       freetext^0.5
       author_main^2.0
       author_person
       au_other
       author_corporation
       title^1.8 
       se
       main_title^4.0
       html_h1
       html_h2
       html_h3
       html_h4
       html_h5
       html_h6
       subject_dk5
       subject_serial_solutions
       subject_ulrichs
       subject_controlled^1.2
       subject_other
       lma_long
       id     
       enrich_editor^0.2
       enrich_isbn^0.2
       enrich_publisher^0.2
       enrich_publishdate^0.2
       enrich_title^0.2
       enrich_head^0.2
       enrich_freetext^0.05
       lti                                                 
     </str>
     <str name="fl">*,score</str>

     <str name="facet">on</str>
     <str name="facet.mincount">1</str>
     <str name="facet.limit">75</str>
     
     <str name="facet.field">recordBase</str>     
     <str name="facet.field">lma_long</str>
     <str name="facet.field">lsubject</str>
     <str name="facet.field">location_normalised</str>
     <str name="facet.field">author_normalised</str>
     <str name="facet.field">llfo</str>
     <str name="facet.field">year</str>
     <str name="facet.field">llang</str>
     <str name="facet.field">lcl_all</str>
     <str name="facet.field">su_dk</str>
     <str name="facet.field">su_lc</str>
     <str name="facet.field">mesh</str>
     <str name="facet.field">ldk5</str>
     <str name="facet.field">lddc</str>
     <str name="facet.field">lnlm</str>
     <str name="facet.field">lkl</str>
     <str name="facet.field">lti</str>
     <str name="facet.field">lperi</str>
     <str name="facet.field">ava</str>
     
     <!--Virtual fields(summa alias/alias-groups) for query -->
     <str name="f.titel.qf">title^1.8</str>
     <str name="f.ti.qf">title^1.8 se main_title^4.0</str>
     <str name="f.cl.qf">class_other ddc_kw dk inst kl lcc_kw nlm_kw</str>
     <str name="f.au.qf">author_main author_person au_other author_corporation</str>
     <str name="f.fo.qf">author_main author_person au_other author_corporation</str>
     <str name="f.lma.qf">lma_long</str>
     <str name="f.ma.qf">ma_short</str>
     <str name="f.numbers.qf">isbn issn number standard_number id ww fmlb fubl</str>
     <str name="f.nr.qf">isbn issn number standard_number id ww fmlb fubl</str>
     <str name="f.lsubj.qf">mesh su_corp su_lc su_pe lsu_ser_sol lsu_ulrichs lsu_ulrichs_hier su_dk lsu_oai lsubject led</str>
     <str name="f.lem.qf">mesh su_corp su_lc su_pe lsu_ser_sol lsu_ulrichs lsu_ulrichs_hier su_dk lsu_oai lsubject led</str>
     <str name="f.su.qf">subject_dk5 subject_serial_solutions subject_ulrichs subject_controlled^1.2 subject_other</str>
     <str name="f.em.qf">subject_dk5 subject_serial_solutions subject_ulrichs subject_controlled^1.2 subject_other</str>
     <str name="f.lcl.qf">lcl_csa lcl_all ldbk lddc ldk5 lfn linst lkl llcc lnlm ludk</str>
     <str name="f.html_header.qf">html_h1 html_h2 html_h3 html_h4 html_h5 html_h6</str>
     <str name="f.enrich_header.qf">enrich_editor^0.2 enrich_isbn^0.2 enrich_publisher^0.2 enrich_publishdate^0.2 enrich_title^0.2 enrich_head^0.2 enrich_freetext^0.05</str>         

       <!-- Spellcheck (DidyouMean) setup -->
       <str  name="spellcheck.dictionary">summa_spell</str>
       <bool name="spellcheck.extendedResults">true</bool>
       <bool name="spellcheck.collate">true</bool>
       <bool name="spellcheck.collateExtendedResults">true</bool>
       <int  name="spellcheck.maxCollationTries">5</int>
       <int  name="spellcheck.count">5</int>

   </lst>
   <arr name="last-components">
      <str>spellcheck</str>
   </arr>
   
</requestHandler>


  <requestHandler name="/update" class="solr.UpdateRequestHandler">
    <!-- See below for information on defining 
         updateRequestProcessorChains that can be used by name 
         on each Update Request
      -->
    <!--
       <lst name="defaults">
         <str name="update.chain">dedupe</str>
       </lst>
       -->
  </requestHandler>
  


  <requestHandler name="/update/extract" 
                  startup="lazy"
                  class="solr.extraction.ExtractingRequestHandler" >
    <lst name="defaults">
      <!-- All the main content goes into "text"... if you need to return
           the extracted text or do highlighting, use a stored field. -->
      <str name="fmap.content">text</str>
      <str name="lowernames">true</str>
      <str name="uprefix">ignored_</str>

      <!-- capture link hrefs but ignore div attributes -->
      <str name="captureAttr">true</str>
      <str name="fmap.a">links</str>
      <str name="fmap.div">ignored_</str>
    </lst>
  </requestHandler>

  <requestHandler name="/analysis/field" 
                  startup="lazy"
                  class="solr.FieldAnalysisRequestHandler" />


  <requestHandler name="/analysis/document" 
                  class="solr.DocumentAnalysisRequestHandler" 
                  startup="lazy" />


  <requestHandler name="/admin/" 
                  class="solr.admin.AdminHandlers" />

  <!-- ping/healthcheck -->
  <requestHandler name="/admin/ping" class="solr.PingRequestHandler">
    <lst name="invariants">
      <str name="q">solrpingquery</str>
    </lst>
    <lst name="defaults">
      <str name="echoParams">all</str>
    </lst>   
    <!-- <str name="healthcheckFile">server-enabled.txt</str> -->
  </requestHandler>

  <!-- Echo the request contents back to the client -->
  <requestHandler name="/debug/dump" class="solr.DumpRequestHandler" >
    <lst name="defaults">
     <str name="echoParams">explicit</str> 
     <str name="echoHandler">true</str>
    </lst>
  </requestHandler>
  
  
  <searchComponent name="spellcheck" class="solr.SpellCheckComponent">

    <str name="queryAnalyzerFieldType">textSpell</str>
    
    <!-- a spellchecker built from a field of the main index. Use spellcheck.dictionary=summa_spell for this-->

    <lst name="spellchecker">    
      <str name="name">summa_spell</str>
      <str name="field">summa_spell</str>
      <str name="buildOnCommit">true</str>
      <str name="spellcheckIndexDir">./spellchecker_summa_spell</str>                  
    </lst>

  </searchComponent>

    <!-- For collation suggestions to work, this must be paired with the dismax -->
<!--    <requestHandler name="/didyoumean" class="solr.SearchHandler">
        <lst name="defaults">
            <str name="echoParams">explicit</str>

            <str  name="spellcheck.dictionary">summa_spell</str>
            <bool name="spellcheck.extendedResults">true</bool>
            <bool name="spellcheck.collate">true</bool>
            <bool name="spellcheck.collateExtendedResults">true</bool>
            <int  name="spellcheck.maxCollationTries">5</int>
            <int  name="spellcheck.count">5</int>

            <str name="defType">edismax</str>
            <str name="qf">
              freetext^0.5
            </str>

        </lst>
      <arr name="last-components">
        <str>spellcheck</str>
      </arr>
    </requestHandler>-->


  <!-- A request handler for demonstrating the spellcheck component.  

       NOTE: This is purely as an example.  The whole purpose of the
       SpellCheckComponent is to hook it into the request handler that
       handles your normal user queries so that a separate request is
       not needed to get suggestions.

       IN OTHER WORDS, THERE IS REALLY GOOD CHANCE THE SETUP BELOW IS
       NOT WHAT YOU WANT FOR YOUR PRODUCTION SYSTEM!
       
       See http://wiki.apache.org/solr/SpellCheckComponent for details
       on the request parameters.
    -->
 
 

  <!-- Term Vector Component

       http://wiki.apache.org/solr/TermVectorComponent
    -->
  <searchComponent name="tvComponent" class="solr.TermVectorComponent"/>

  <!-- A request handler for demonstrating the term vector component

       This is purely as an example.

       In reality you will likely want to add the component to your 
       already specified request handlers. 
    -->
  <requestHandler name="tvrh" class="solr.SearchHandler" startup="lazy">
    <lst name="defaults">
      <bool name="tv">true</bool>
    </lst>
    <arr name="last-components">
      <str>tvComponent</str>
    </arr>
  </requestHandler>

  <!-- Clustering Component

       http://wiki.apache.org/solr/ClusteringComponent

       You'll need to set the solr.cluster.enabled system property 
       when running solr to run with clustering enabled:

       java -Dsolr.clustering.enabled=true -jar start.jar
    -->
  <searchComponent name="clustering" 
                   enable="${solr.clustering.enabled:false}"
                   class="solr.clustering.ClusteringComponent" >
    <!-- Declare an engine -->
    <lst name="engine">
      <!-- The name, only one can be named "default" -->
      <str name="name">default</str>

      <!-- Class name of Carrot2 clustering algorithm.

           Currently available algorithms are:
           
           * org.carrot2.clustering.lingo.LingoClusteringAlgorithm
           * org.carrot2.clustering.stc.STCClusteringAlgorithm
           * org.carrot2.clustering.kmeans.BisectingKMeansClusteringAlgorithm
           
           See http://project.carrot2.org/algorithms.html for the
           algorithm's characteristics.
        -->
      <str name="carrot.algorithm">org.carrot2.clustering.lingo.LingoClusteringAlgorithm</str>

      <!-- Overriding values for Carrot2 default algorithm attributes.

           For a description of all available attributes, see:
           http://download.carrot2.org/stable/manual/#chapter.components.
           Use attribute key as name attribute of str elements
           below. These can be further overridden for individual
           requests by specifying attribute key as request parameter
           name and attribute value as parameter value.
        -->
      <str name="LingoClusteringAlgorithm.desiredClusterCountBase">20</str>

      <!-- Location of Carrot2 lexical resources.

           A directory from which to load Carrot2-specific stop words
           and stop labels. Absolute or relative to Solr config directory.
           If a specific resource (e.g. stopwords.en) is present in the
           specified dir, it will completely override the corresponding
           default one that ships with Carrot2.

           For an overview of Carrot2 lexical resources, see:
           http://download.carrot2.org/head/manual/#chapter.lexical-resources
        -->
      <str name="carrot.lexicalResourcesDir">clustering/carrot2</str>

      <!-- The language to assume for the documents.

           For a list of allowed values, see:
           http://download.carrot2.org/stable/manual/#section.attribute.lingo.MultilingualClustering.defaultLanguage
       -->
      <str name="MultilingualClustering.defaultLanguage">ENGLISH</str>
    </lst>
    <lst name="engine">
      <str name="name">stc</str>
      <str name="carrot.algorithm">org.carrot2.clustering.stc.STCClusteringAlgorithm</str>
    </lst>
  </searchComponent>

  <!-- A request handler for demonstrating the clustering component

       This is purely as an example.

       In reality you will likely want to add the component to your 
       already specified request handlers. 
    -->
  <requestHandler name="/clustering"
                  startup="lazy"
                  enable="${solr.clustering.enabled:false}"
                  class="solr.SearchHandler">
    <lst name="defaults">
      <bool name="clustering">true</bool>
      <str name="clustering.engine">default</str>
      <bool name="clustering.results">true</bool>
      <!-- The title field -->
      <str name="carrot.title">name</str>
      <str name="carrot.url">id</str>
      <!-- The field to cluster on -->
       <str name="carrot.snippet">features</str>
       <!-- produce summaries -->
       <bool name="carrot.produceSummary">true</bool>
       <!-- the maximum number of labels per cluster -->
       <!--<int name="carrot.numDescriptions">5</int>-->
       <!-- produce sub clusters -->
       <bool name="carrot.outputSubClusters">false</bool>
       
       <str name="defType">edismax</str>
       <str name="qf">
         text^0.5 features^1.0 name^1.2 sku^1.5 id^10.0 manu^1.1 cat^1.4
       </str>
       <str name="q.alt">*:*</str>
       <str name="rows">10</str>
       <str name="fl">*,score</str>
    </lst>     
    <arr name="last-components">
      <str>clustering</str>
    </arr>
  </requestHandler>
  
  <!-- Terms Component

       http://wiki.apache.org/solr/TermsComponent

       A component to return terms and document frequency of those
       terms
    -->
  <searchComponent name="terms" class="solr.TermsComponent"/>

  <!-- A request handler for demonstrating the terms component -->
  <requestHandler name="/terms" class="solr.SearchHandler" startup="lazy">
     <lst name="defaults">
      <bool name="terms">true</bool>
    </lst>     
    <arr name="components">
      <str>terms</str>
    </arr>
  </requestHandler>


  <!-- Query Elevation Component

       http://wiki.apache.org/solr/QueryElevationComponent

       a search component that enables you to configure the top
       results for a given query regardless of the normal lucene
       scoring.
    -->
  <searchComponent name="elevator" class="solr.QueryElevationComponent" >
    <!-- pick a fieldType to analyze queries -->
    <str name="queryFieldType">string</str>
    <str name="config-file">elevate.xml</str>
  </searchComponent>

  <!-- A request handler for demonstrating the elevator component -->
  <requestHandler name="/elevate" class="solr.SearchHandler" startup="lazy">
    <lst name="defaults">
      <str name="echoParams">explicit</str>
    </lst>
    <arr name="last-components">
      <str>elevator</str>
    </arr>
  </requestHandler>

  <!-- Highlighting Component

       http://wiki.apache.org/solr/HighlightingParameters
    -->
  <searchComponent class="solr.HighlightComponent" name="highlight">
    <highlighting>
      <!-- Configure the standard fragmenter -->
      <!-- This could most likely be commented out in the "default" case -->
      <fragmenter name="gap" 
                  default="true"
                  class="solr.highlight.GapFragmenter">
        <lst name="defaults">
          <int name="hl.fragsize">100</int>
        </lst>
      </fragmenter>

      <!-- A regular-expression-based fragmenter 
           (for sentence extraction) 
        -->
      <fragmenter name="regex" 
                  class="solr.highlight.RegexFragmenter">
        <lst name="defaults">
          <!-- slightly smaller fragsizes work better because of slop -->
          <int name="hl.fragsize">70</int>
          <!-- allow 50% slop on fragment sizes -->
          <float name="hl.regex.slop">0.5</float>
          <!-- a basic sentence pattern -->
          <str name="hl.regex.pattern">[-\w ,/\n\&quot;&apos;]{20,200}</str>
        </lst>
      </fragmenter>

      <!-- Configure the standard formatter -->
      <formatter name="html" 
                 default="true"
                 class="solr.highlight.HtmlFormatter">
        <lst name="defaults">
          <str name="hl.simple.pre"><![CDATA[<em>]]></str>
          <str name="hl.simple.post"><![CDATA[</em>]]></str>
        </lst>
      </formatter>

      <!-- Configure the standard encoder -->
      <encoder name="html" 
               class="solr.highlight.HtmlEncoder" />

      <!-- Configure the standard fragListBuilder -->
      <fragListBuilder name="simple" 
                       default="true"
                       class="solr.highlight.SimpleFragListBuilder"/>

      <!-- Configure the single fragListBuilder -->
      <fragListBuilder name="single" 
                       class="solr.highlight.SingleFragListBuilder"/>

      <!-- default tag FragmentsBuilder -->
      <fragmentsBuilder name="default" 
                        default="true"
                        class="solr.highlight.ScoreOrderFragmentsBuilder">
        <!-- 
        <lst name="defaults">
          <str name="hl.multiValuedSeparatorChar">/</str>
        </lst>
        -->
      </fragmentsBuilder>

      <!-- multi-colored tag FragmentsBuilder -->
      <fragmentsBuilder name="colored" 
                        class="solr.highlight.ScoreOrderFragmentsBuilder">
        <lst name="defaults">
          <str name="hl.tag.pre"><![CDATA[
               <b style="background:yellow">,<b style="background:lawgreen">,
               <b style="background:aquamarine">,<b style="background:magenta">,
               <b style="background:palegreen">,<b style="background:coral">,
               <b style="background:wheat">,<b style="background:khaki">,
               <b style="background:lime">,<b style="background:deepskyblue">]]></str>
          <str name="hl.tag.post"><![CDATA[</b>]]></str>
        </lst>
      </fragmentsBuilder>
      
      <boundaryScanner name="default" 
                       default="true"
                       class="solr.highlight.SimpleBoundaryScanner">
        <lst name="defaults">
          <str name="hl.bs.maxScan">10</str>
          <str name="hl.bs.chars">.,!? &#9;&#10;&#13;</str>
        </lst>
      </boundaryScanner>
      
      <boundaryScanner name="breakIterator" 
                       class="solr.highlight.BreakIteratorBoundaryScanner">
        <lst name="defaults">
          <!-- type should be one of CHARACTER, WORD(default), LINE and SENTENCE -->
          <str name="hl.bs.type">WORD</str>
          <!-- language and country are used when constructing Locale object.  -->
          <!-- And the Locale object will be used when getting instance of BreakIterator -->
          <str name="hl.bs.language">en</str>
          <str name="hl.bs.country">US</str>
        </lst>
      </boundaryScanner>
    </highlighting>
  </searchComponent>

  <!-- Update Processors

       Chains of Update Processor Factories for dealing with Update
       Requests can be declared, and then used by name in Update
       Request Processors

       http://wiki.apache.org/solr/UpdateRequestProcessor

    --> 
  <!-- Deduplication

       An example dedup update processor that creates the "id" field
       on the fly based on the hash code of some other fields.  This
       example has overwriteDupes set to false since we are using the
       id field as the signatureField and Solr will maintain
       uniqueness based on that anyway.  
       
    -->
  <!--
     <updateRequestProcessorChain name="dedupe">
       <processor class="solr.processor.SignatureUpdateProcessorFactory">
         <bool name="enabled">true</bool>
         <str name="signatureField">id</str>
         <bool name="overwriteDupes">false</bool>
         <str name="fields">name,features,cat</str>
         <str name="signatureClass">solr.processor.Lookup3Signature</str>
       </processor>
       <processor class="solr.LogUpdateProcessorFactory" />
       <processor class="solr.RunUpdateProcessorFactory" />
     </updateRequestProcessorChain>
    -->
  
  <!-- Language identification

       This example update chain identifies the language of the incoming
       documents using the langid contrib. The detected language is
       written to field language_s. No field name mapping is done.
       The fields used for detection are text, title, subject and description,
       making this example suitable for detecting languages form full-text
       rich documents injected via ExtractingRequestHandler.
       See more about langId at http://wiki.apache.org/solr/LanguageDetection
    -->
    <!--
     <updateRequestProcessorChain name="langid">
       <processor class="org.apache.solr.update.processor.TikaLanguageIdentifierUpdateProcessorFactory">
         <str name="langid.fl">text,title,subject,description</str>
         <str name="langid.langField">language_s</str>
         <str name="langid.fallback">en</str>
       </processor>
       <processor class="solr.LogUpdateProcessorFactory" />
       <processor class="solr.RunUpdateProcessorFactory" />
     </updateRequestProcessorChain>
    -->
 
  <!-- Response Writers

       http://wiki.apache.org/solr/QueryResponseWriter

       Request responses will be written using the writer specified by
       the 'wt' request parameter matching the name of a registered
       writer.

       The "default" writer is the default and will be used if 'wt' is
       not specified in the request.
    -->
  <!-- The following response writers are implicitly configured unless
       overridden...
    -->
  <!--
     <queryResponseWriter name="xml" 
                          default="true"
                          class="solr.XMLResponseWriter" />
     <queryResponseWriter name="json" class="solr.JSONResponseWriter"/>
     <queryResponseWriter name="python" class="solr.PythonResponseWriter"/>
     <queryResponseWriter name="ruby" class="solr.RubyResponseWriter"/>
     <queryResponseWriter name="php" class="solr.PHPResponseWriter"/>
     <queryResponseWriter name="phps" class="solr.PHPSerializedResponseWriter"/>
     <queryResponseWriter name="csv" class="solr.CSVResponseWriter"/>
    -->

  <queryResponseWriter name="json" class="solr.JSONResponseWriter">
     <!-- For the purposes of the tutorial, JSON responses are written as
      plain text so that they are easy to read in *any* browser.
      If you expect a MIME type of "application/json" just remove this override.
     -->
    <str name="content-type">text/plain; charset=UTF-8</str>
  </queryResponseWriter>
  
  <!--
     Custom response writers can be declared as needed...
    -->
    <queryResponseWriter name="velocity" class="solr.VelocityResponseWriter" startup="lazy"/>
  

  <!-- XSLT response writer transforms the XML output by any xslt file found
       in Solr's conf/xslt directory.  Changes to xslt files are checked for
       every xsltCacheLifetimeSeconds.  
    -->
  <queryResponseWriter name="xslt" class="solr.XSLTResponseWriter">
    <int name="xsltCacheLifetimeSeconds">5</int>
  </queryResponseWriter>

  <!-- Query Parsers

       http://wiki.apache.org/solr/SolrQuerySyntax

       Multiple QParserPlugins can be registered by name, and then
       used in either the "defType" param for the QueryComponent (used
       by SearchHandler) or in LocalParams
    -->
  <!-- example of registering a query parser -->
  <!--
     <queryParser name="myparser" class="com.mycompany.MyQParserPlugin"/>
    -->

  <!-- Function Parsers

       http://wiki.apache.org/solr/FunctionQuery

       Multiple ValueSourceParsers can be registered by name, and then
       used as function names when using the "func" QParser.
    -->
  <!-- example of registering a custom function parser  -->
  <!--
     <valueSourceParser name="myfunc" 
                        class="com.mycompany.MyValueSourceParser" />
    -->
    
  
  <!-- Document Transformers
       http://wiki.apache.org/solr/DocTransformers
    -->
  <!--
     Could be something like:
     <transformer name="db" class="com.mycompany.LoadFromDatabaseTransformer" >
       <int name="connection">jdbc://....</int>
     </transformer>
     
     To add a constant value to all docs, use:
     <transformer name="mytrans2" class="org.apache.solr.response.transform.ValueAugmenterFactory" >
       <int name="value">5</int>
     </transformer>
     
     If you want the user to still be able to change it with _value:something_ use this:
     <transformer name="mytrans3" class="org.apache.solr.response.transform.ValueAugmenterFactory" >
       <double name="defaultValue">5</double>
     </transformer>

      If you are using the QueryElevationComponent, you may wish to mark documents that get boosted.  The
      EditorialMarkerFactory will do exactly that:
     <transformer name="qecBooster" class="org.apache.solr.response.transform.EditorialMarkerFactory" />
    -->
    

  <!-- Legacy config for the admin interface -->
  <admin>
    <defaultQuery>*:*</defaultQuery>
  </admin>


    <!-- Component developed by Statsbiblioteket for (hierarchical) faceting -->
    <searchComponent name="exposed" class="org.apache.solr.exposed.ExposedFacetQueryComponent">
      <lst name="poolfactory">
        <int name="pools">10</int>
        <int name="filled">5</int>
        <int name="fresh">5</int>
      </lst>
    </searchComponent>

    <requestHandler name="/exposed" class="org.apache.solr.handler.component.SearchHandler">
      <arr name="last-components">
        <str>exposed</str>
      </arr>
    </requestHandler>

    <!-- Component developed by Statsbiblioteket for index lookup -->
    <searchComponent name="lookup" class="org.apache.solr.exposed.ExposedIndexLookupQueryComponent">
      <lst name="poolfactory">
        <int name="pools">6</int>
        <int name="filled">2</int>
        <int name="fresh">2</int>
      </lst>
    </searchComponent>

    <requestHandler name="/lookup" class="org.apache.solr.handler.component.SearchHandler">
      <arr name="last-components">
        <str>lookup</str>
      </arr>
    </requestHandler>

</config>
