/* $Id$
 * $Revision$
 * $Date$
 * $Author$
 *
 * The Summa project.
 * Copyright (C) 2005-2008  The State and University Library
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */
package dk.statsbiblioteket.summa.ingest.stream;

import javax.xml.stream.XMLStreamReader;
import javax.xml.stream.XMLInputFactory;
import javax.xml.stream.XMLStreamException;
import javax.xml.stream.events.XMLEvent;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.Collections;
import java.util.Hashtable;
import java.text.ParseException;
import java.io.StringWriter;
import java.io.UnsupportedEncodingException;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import dk.statsbiblioteket.util.qa.QAInfo;
import dk.statsbiblioteket.summa.common.filter.Payload;
import dk.statsbiblioteket.summa.common.Record;
import dk.statsbiblioteket.summa.common.util.ParseUtil;
import dk.statsbiblioteket.summa.common.configuration.Configuration;

/**
 * Takes a Stream as input, splits into MARC-records and creates Summa-Records
 * with the content. As part of the split, the following properties are
 * extracted from the MARC-record:
 * <ul>
 *   <li>recordID</li>
 *   <li>state (deleted or not)</li>
 *   <li>parent/child relations</li>
 * </ul>
 * </p><p>
 * The extraction of recordID and parent/child-relations is non-trivial due to
 * the nature of MARC, so the input is parsed. A streaming parser is used as
 * performance is prioritized over clarity (the streaming parser has less
 * GC overhead than a full DOM build).
 * </p><p>
 * The overall structure of a MARC-dump is
 * {@code
<collection xmlns="http://www.loc.gov/MARC21/slim">
<record>
  <leader>...</leader>
  <datafield tag="..." ind1="..." ind2="...">
    <subfield code="...">...</subfield>+
  </datafield>*
</record>*
</collection>
} where * indicates multiple and + at least one occurence of the element.
 * </p><p>
 * There are different variants of MARC, but the structure is always the same
 * (well, at least we think so - MARC is a fixed target).
 */
@QAInfo(level = QAInfo.Level.NORMAL,
        state = QAInfo.State.IN_DEVELOPMENT,
        author = "te")
public class MARCParser extends ThreadedStreamParser {
    private static Log log = LogFactory.getLog(MARCParser.class);

    /**
     * The base for the Records generated by the parser.
     * </p><p>
     * This property is mandatory.
     */
    public static final String CONF_BASE = "summa.ingest.marcparser.base";

    @SuppressWarnings({"DuplicateStringLiteralInspection"})
    public static final String MARC_RECORD_TAG = "record";
    private XMLInputFactory inputFactory;
    private String base;

    public MARCParser(Configuration conf) {
        super(conf);
        inputFactory = XMLInputFactory.newInstance();
        // There should be no CData in the MARC XML
//        inputFactory.setProperty("report-cdata-event", Boolean.TRUE);
        inputFactory.setProperty(XMLInputFactory.IS_COALESCING, Boolean.TRUE);
        base = conf.getString(CONF_BASE, null);
        if (base == null) {
            throw new ConfigurationException(String.format(
                    "A base must be specified with key %s", CONF_BASE));
        }
    }

    // http://java.sun.com/javaee/5/docs/tutorial/doc/bnbfl.html
    protected void protectedRun() throws Exception {
        XMLStreamReader reader = inputFactory.createXMLStreamReader(
                sourcePayload.getStream(), "utf-8");
        // Positioned at startDocument
        int eventType = reader.getEventType();
        if (eventType != XMLEvent.START_ELEMENT) {
            throw new ParseException("The first element was not start", 0);
        }

        while (running && reader.hasNext()) {
            eventType = reader.next();
            //noinspection DuplicateStringLiteralInspection
            if (eventType == XMLEvent.START_ELEMENT
                && MARC_RECORD_TAG.equals(reader.getLocalName())) {
                processInRecord(reader);
            }
        }
    }

    /**
     * Collect record information and ultimately build a Record before
     * returning.
     * @param reader a reader positioned at the start of a record.
     * @throws XMLStreamException if a perse error occured.
     */
    private void processInRecord(XMLStreamReader reader) throws
                                                         XMLStreamException {
        StringWriter content = new StringWriter(2000); // Full MARC content
        String id = null;

        content.append(beginTagToString(reader));
        while (running && reader.hasNext()) {
            int eventType = reader.next();

            switch(eventType) {
                case XMLEvent.END_ELEMENT :
                    content.append("<").append(reader.getLocalName()).
                            append(">\n");
                    if (MARC_RECORD_TAG.equals(reader.getLocalName())) {
                        makeRecord(id, content);
                        return;
                    }
                    break;
                case XMLEvent.START_ELEMENT :
                    content.append(beginTagToString(reader));
                    break;
                case XMLEvent.CHARACTERS :
                    // TODO: Test for "foo &lt;bar"
                    content.append(reader.getText());
                    break;
                default:
                    log.warn("Unexpended event while processing record: "
                             + eventID2String(eventType));
            }
        }
    }

    /**
     * Create a Record with the given id and content, then add it to the queue.
     * @param id      the id for the Record.
     * @param content the content of the Record.
     */
    private void makeRecord(String id, StringWriter content) {
        if (running) {
            if (id == null) {
                if (log.isDebugEnabled()) {
                    log.warn(String.format(
                            "Could not extract id from content " + content));
                } else {
                    log.warn("Could not extract id from content");
                }
                return;
            }
            try {
                log.debug("processInRecord: Adding record with id '" + id
                          + "' to the queue");
                queue.put(new Record(
                        id, base, content.toString().getBytes("utf-8")));
            } catch (UnsupportedEncodingException e) {
                throw new RuntimeException(
                        "utf-8 not supported in String.getBytes(\"utf-8)\")",
                        e);
            } catch (InterruptedException e) {
                throw new RuntimeException(String.format(
                        "Interrupted while trying to add Record with id '%s' to"
                        + " queue", id), e);
            }
        }
    }

    /**
     * Convert a begin-tag to String. Suitable for dumping while parsing.
     * @param reader a reader pointing to a vegin-tag.
     * @return the begin-tag as text.
     */
    private String beginTagToString(XMLStreamReader reader) {
        StringWriter tag = new StringWriter(50);
        tag.append("<").append(reader.getLocalName());
        for (int i = 0 ; i < reader.getAttributeCount() ; i++) {
            tag.append(" ").append(reader.getAttributeLocalName(i));
            tag.append("=\"");
            tag.append(ParseUtil.encode(reader.getAttributeValue(i)));
            tag.append("\"");
        }
        tag.append(">");
        return tag.toString();
    }

    /**
     * Udef for debugging. Converts an XMLEvent-id to String.
     * @param eventType the event id.
     * @return the event as human redable String.
     */
    private String eventID2String(int eventType) {
        switch (eventType) {
            case XMLEvent.START_ELEMENT:  return "START_ELEMENT";
            case XMLEvent.END_ELEMENT:    return "END_ELEMENT";
            case XMLEvent.PROCESSING_INSTRUCTION:
                return "PROCESSING_INSTRUCTION";
            case XMLEvent.CHARACTERS: return "CHARACTERS";
            case XMLEvent.COMMENT: return "COMMENT";
            case XMLEvent.START_DOCUMENT: return "START_DOCUMENT";
            case XMLEvent.END_DOCUMENT: return "END_DOCUMENT";
            case XMLEvent.ENTITY_REFERENCE: return "ENTITY_REFERENCE";
            case XMLEvent.ATTRIBUTE: return "ATTRIBUTE";
            case XMLEvent.DTD: return "DTD";
            case XMLEvent.CDATA: return "CDATA";
            case XMLEvent.SPACE: return "SPACE";
            default: return "UNKNOWN_EVENT_TYPE " + "," + eventType;
        }
    }
}
